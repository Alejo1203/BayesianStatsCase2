---
title: "Caso 2"
author: "Sebastián Lozano, Jherson Guzman"
date: "7/10/2023"
output: pdf_document
---

```{r setup, include=FALSE}
setwd("C:/Bayesiana/Caso2")
```


```{r, include=FALSE,include=FALSE}
Sys.setlocale(category = "LC_COLLATE", locale = "Spanish_Colombia.utf8")
Sys.setlocale(category = "LC_CTYPE", locale = "Spanish_Colombia.utf8")
Sys.setlocale(category = "LC_MONETARY", locale = "Spanish_Colombia.utf8")
Sys.setlocale(category = "LC_NUMERIC", locale = "C")
Sys.setlocale(category = "LC_TIME", locale = "Spanish_Colombia.utf8")
```


```{r cargar datos, y librería,include=FALSE}
library(readr)
library(readxl)
library(dplyr)
library(ggplot2)

#setwd("C:/Users/57300/OneDrive/Documentos/GitHub/BayesianStatsCase2")
Saber11 <- read_delim("C:/Bayesiana/Caso2/SB11_20222.TXT", 
  delim = ";", escape_double = FALSE, locale = locale(), 
  trim_ws = TRUE)

```

```{r Tratamiento de datos, include=FALSE}
#Nacionalidad colombiana
#Residencia en Colombia
#Proceso de investigación en el Icfes en estado de “Publicar”.
#Ubicación del colegio no es San Andrés.
#Sin datos faltantes en la ubicación del colegio por municipio, la ubicación del colegio por departamento y el puntaje global

datos <- Saber11 %>%
  filter(ESTU_NACIONALIDAD == "COLOMBIA"&
           ESTU_PAIS_RESIDE == "COLOMBIA" &
            COLE_COD_DEPTO_UBICACION != 88 &
           ESTU_ESTADOINVESTIGACION=="PUBLICAR" 
           ) %>%
  as.data.frame()

nrow(datos)

#ya hay 525061

# cambiamos COLE_COD_DEPTO_UBICACION a char
datos$COLE_COD_DEPTO_UBICACION<-as.character(datos$COLE_COD_DEPTO_UBICACION)
datos$COLE_COD_DEPTO_UBICACION<-ifelse(datos$COLE_COD_DEPTO_UBICACION=="5","05",datos$COLE_COD_DEPTO_UBICACION)
datos$COLE_COD_DEPTO_UBICACION<-ifelse(datos$COLE_COD_DEPTO_UBICACION=="8","08",datos$COLE_COD_DEPTO_UBICACION)

# cambiamos COLE_COD_MCPIO_UBICACION a char
datos$COLE_COD_MCPIO_UBICACION<-as.character(datos$COLE_COD_MCPIO_UBICACION)
datos$COLE_COD_MCPIO_UBICACION<-ifelse(datos$COLE_COD_DEPTO_UBICACION=="05",paste("0",datos$COLE_COD_MCPIO_UBICACION,sep=""),datos$COLE_COD_MCPIO_UBICACION)
datos$COLE_COD_MCPIO_UBICACION<-ifelse(datos$COLE_COD_DEPTO_UBICACION=="08",paste("0",datos$COLE_COD_MCPIO_UBICACION,sep=""),datos$COLE_COD_MCPIO_UBICACION)


# Revisamos que no hayan datos faltantes
sum(is.na(datos$COLE_COD_MCPIO_UBICACION))
sum(is.na(datos$COLE_COD_DEPTO_UBICACION))
sum(is.na(datos$PUNT_GLOBAL))

##Guardamos los datos, para su posterior manipulación.
#save(datos, file = "saber11modificado.rdata")

```

## Punto 1
```{r preparacion de la base de datos, include=FALSE}
combinados <- cbind(datos$COLE_DEPTO_UBICACION,datos$COLE_COD_DEPTO_UBICACION)
cod <- as.data.frame(unique(combinados))
cod <- setNames(cod, c("dep", "cod_dep"))
```

```{r, include=FALSE}
pobreza_monetaria <- read_excel("C:/Bayesiana/Caso2/pobreza monetaria.xls",sheet = "Pobreza Monetaria (%)", range = "A16:P40")

pobreza_monetaria <- pobreza_monetaria[,c(1,16)]
pobreza_monetaria <- setNames(pobreza_monetaria,c("dep","IP2018"))

codigos_departamentos <- c("05", "08", "11", "13", "15", "17", "18", "19", "20", "27", "23", "25", "41", "44", "47", "50", "52", "54", "63", "66", "68", "70", "73", "76")

pobreza_monetaria$cod_dep <- codigos_departamentos

punt_muestrales <- datos %>%
  group_by(COLE_COD_DEPTO_UBICACION) %>%
  summarise(puntmedio = mean(PUNT_GLOBAL)) %>%
  as.data.frame()

Mapa <- punt_muestrales %>%
  full_join(pobreza_monetaria,by = c("COLE_COD_DEPTO_UBICACION"="cod_dep"))%>%
  select(COLE_COD_DEPTO_UBICACION,dep,IP2018,puntmedio) %>%
  as.data.frame()

Mapa <- setNames(Mapa,c("cod_dep","dep","IP2018","puntmedio"))
```

```{r gráficas, include=FALSE}
library(sf)

deptoshp <- st_read("MGN_DPTO_POLITICO.shp",quiet=TRUE) 

mapdeptos <- deptoshp %>%
  left_join(Mapa,by=c("DPTO_CCDGO"="cod_dep")) 

mundoshp <- st_read("admin00.shp",quiet=TRUE)
mundocol <- mundoshp %>% 
            filter(CNTRY_NAME %in% c("Peru","Brazil","Venezuela","Ecuador","Panama"))
str(mundocol)
```

```{r}
library(ggplot2)
box <- st_bbox(mapdeptos)

plot1 <- ggplot() +
  geom_sf(data = mundocol) +
  geom_sf(data = mapdeptos, aes(fill = puntmedio), col = "darkgray", linetype = "solid") +
  coord_sf(xlim = c(box$xmin, box$xmax), ylim = c(box$ymin, box$ymax), expand = FALSE) +
  geom_sf_text(data = mapdeptos, aes(label = ifelse(puntmedio < quantile(puntmedio, probs = 0.10, na.rm = TRUE), DPTO_CNMBR, "")), col = "black",
               fontface = "bold", size = 2, fun.geometry = function(x) sf::st_centroid(x)) +
  labs(x = "Longitud", y = "Latitud", title = "Puntaje medio en las \npruebas Saber Pro \ndepartamento en 2022-II", fill = "Puntaje \nmedio") +
  scale_fill_gradient(low = "white", high = "#00FFFF", n.breaks = 5)

plot2 <- ggplot() +
  geom_sf(data = mundocol) +
  geom_sf(data = mapdeptos, aes(fill = IP2018), col = "darkgray", linetype = "solid") +
  coord_sf(xlim = c(box$xmin, box$xmax), ylim = c(box$ymin, box$ymax), expand = FALSE) +
  geom_sf_text(data = mapdeptos, aes(label = ifelse(IP2018 > quantile(IP2018, probs = 0.90, na.rm = TRUE), DPTO_CNMBR, "")), col = "black",
               fontface = "bold", size = 2, fun.geometry = function(x) sf::st_centroid(x)) +
  labs(x = "Longitud", y = "Latitud", title = "Índice de pobreza \npor departamento en\n2018", fill = "Índice de \n pobreza" ) +
  scale_fill_gradient(low = "white", high = "#FFD700", n.breaks = 5)

```

```{r}
library(gridExtra)
grid.arrange(plot1, plot2, ncol = 2)
```

## Punto 2

```{r}
library(readr)
library(stringr)
estadisticas_edu <- read_delim("estadísticas_educación.csv",delim = ",")

estadisticas_edu <- estadisticas_edu %>%
  filter(AÑO == 2022) %>%
  select(AÑO,CÓDIGO_MUNICIPIO,MUNICIPIO,CÓDIGO_DEPARTAMENTO,DEPARTAMENTO,COBERTURA_NETA_SECUNDARIA) %>%
  as.data.frame()

punt_muestrales_mpios <- datos %>%
  group_by(COLE_COD_MCPIO_UBICACION) %>%
  summarise(puntmedio = mean(PUNT_GLOBAL)) %>%
  as.data.frame()

punt_muestrales_mpios$COLE_COD_MCPIO_UBICACION <- sub("^00", "0", punt_muestrales_mpios$COLE_COD_MCPIO_UBICACION)

Mapa_mpios <- punt_muestrales_mpios %>%
  full_join(estadisticas_edu,by = c("COLE_COD_MCPIO_UBICACION"="CÓDIGO_MUNICIPIO"))%>%
  as.data.frame()


```
```{r}
mpioshp <- st_read("MGN_MPIO_POLITICO.shp",quiet=TRUE) 
mpioshp$MPIO_COD <- paste(mpioshp$DPTO_CCDGO,mpioshp$MPIO_CCDGO,sep = "")

mapmpios <- mpioshp %>%
  left_join(Mapa_mpios,by=c("MPIO_COD"="COLE_COD_MCPIO_UBICACION")) 

mundoshp <- st_read("admin00.shp",quiet=TRUE)
mundocol <- mundoshp %>% 
            filter(CNTRY_NAME %in% c("Peru","Brazil","Venezuela","Ecuador","Panama"))
```

```{r}
box2 <- st_bbox(mapmpios)

plot3 <- ggplot() +
  geom_sf(data = mundocol) +
  geom_sf(data = mapmpios, aes(fill = puntmedio), col = "gray", linetype = "solid") +
  coord_sf(xlim = c(box2$xmin, box2$xmax), ylim = c(box2$ymin, box2$ymax), expand = FALSE) +
  labs(x = "Longitud", y = "Latitud", title = "Puntaje medio en las \npruebas Saber Pro \npor municipio en 2022-II", fill = "Puntaje \nmedio") +
  scale_fill_gradient(low = "white", high = "#00FFFF", n.breaks = 5)

plot4 <- ggplot() +
  geom_sf(data = mundocol) +
  geom_sf(data = mapmpios, aes(fill = COBERTURA_NETA_SECUNDARIA), col = "gray", linetype = "solid") +
  coord_sf(xlim = c(box2$xmin, box2$xmax), ylim = c(box2$ymin, box2$ymax), expand = FALSE) +
  labs(x = "Longitud", y = "Latitud", title = "Cobertura neta \nsecundaria por municipio \nen 2022", fill = "Cob. \nneta \nsec." ) +
  scale_fill_gradient(low = "white", high = "#00CD00", n.breaks = 5)
```


```{r}
grid.arrange(plot3, plot4, ncol = 2)
```


```{r Implementación Modelos}
mod1 <- function(B,y,mu0,gamma0,nu0,s20){
  #tamaños
  n <- length(y)
  ybar <- mean(y)
  ysum <- sum(y)
  s2 <- var(y)
  
  #valores inicales
  sig2 <- 1/rgamma(n = 1,shape = nu0/2,rate = (nu0*s20)/2)
  
  #calculos previos 
  invgamma0 <- 1/gamma0
  mu0_gamma0 <- mu0/gamma0
  nun_2 <- (n + nu0)/2
  nun <- n+nu0
  nu0xs20 <- nu0*s20
  
  cont <- 1
  #almacenamiento
  THETA <- matrix(data = NA, nrow = (B-1000)/10, ncol = 2)
  LL <- matrix(data = NA, nrow = (B-1000)/10, ncol = 1)
  
  #cadena
  for (b in 1:B) {
    #actualizar theta
    vtheta <- 1/(n/sig2+invgamma0)
    theta <- rnorm(n = 1, mean = (ysum/sig2 + mu0_gamma0)*vtheta, sd = sqrt(vtheta))
    
    #actualizar sigma^2
    s2n   <- nu0xs20+(n-1)*s2+n*(ybar-theta)^2
    sig2 <- 1/rgamma(n = 1, shape = nun_2 , rate = s2n)
    
    
    if(b > 1000 &&  (b - 1000) %% 10 == 0){
    #almacenar valores
     THETA[cont,] <-  c(theta,sig2)
    #Log-verosimilitud
     LL[cont] <- sum(dnorm(x = y, mean = theta, sd = sqrt(sig2),log = TRUE))
     
     cont <- cont+1
    }
  }
  

  #fin de la cadena
  

  colnames(THETA) <- c("theta","sig2")
  colnames(LL) <- c("ll")
  
  THETA <- THETA[!rowSums(is.na(THETA)) == ncol(THETA), ]
  LL <- LL[!rowSums(is.na(LL)) == ncol(LL), ]
  
  #salida
  
  THETA <- as.data.frame(THETA)
  LL <- as.data.frame(LL)
  return(list(THETA = THETA,LL = LL))
}
```


```{r calculo modelo 1}
#Hiperparametros
y <- datos$PUNT_GLOBAL
mu0 <- 250
gamma0 <- 50^2
nu0 <- 1 
s20 <- 50^2


tictoc::tic()
set.seed(2023)
chain1 <- mod1(B = 101000, y = y,mu0 = mu0,gamma0 = gamma0, nu0 = nu0, s20 = s20)
tictoc::toc()
```
```{r, graficas cadena 1}
plot(x = 1:10000, y =  unlist(chain1$LL),type = "p", pch = ".", xlab = "Iteración", ylab = "Log-verosimilitud")
plot(chain1$THETA[,1],type = "p", pch = ".", xlab = "Iteración", ylab = expression(theta))
plot(chain1$THETA[,2],type = "p", pch = ".", xlab = "Iteración", ylab = expression(sigma^2))
```

```{r}
mod2 <- function(B,nj,yb,s2,mu0, g20, eta0, t20, nu0, s20){
  #tamaño 
  n <- sum(nj)
  m <- length(nj)
  
  #valores inciales
  theta <- yb
  sig2  <- mean(s2)
  mu    <- mean(theta)
  tau2  <- var(theta)
  
  #calculos previos
  invg20 <- 1/g20
  mu0_g20 <- mu0/g20
  eta0_m <- eta0+m
  #almacenamiento
  THETA <- matrix(data = NA, nrow = (B-1000)/10, ncol = m+3)
  LL    <- matrix(data = NA, nrow = (B-1000)/10, ncol = 1)
  
  cont <- 1
  #cadena
  for (b in 1:B) {
    #actualizar theta
    vtheta <- 1/(1/tau2 + nj/sig2)
    theta  <- rnorm(n = m, mean = vtheta*(mu/tau2 + nj*yb/sig2), sd = sqrt(vtheta))
    
    #actualizar sigma^2
    sig2 <- 1/rgamma(n = 1, shape = 0.5*(nu0 + n), rate = 0.5*(nu0*s20 + sum((nj-1)*s2 + nj*(yb - theta)^2)))
    
    # actualizar mu
    vmu <- 1/(invg20 + m/tau2)
    mu  <- rnorm(n = 1, mean = vmu*(mu0_g20 + m*mean(theta)/tau2), sd = sqrt(vmu)) 
    
    # actualizar tau^2
    tau2 <- 1/rgamma(n = 1, shape = 0.5*(eta0_m), rate = 0.5*(eta0*t20 + (m-1)*var(theta) + m*(mean(theta) - mu)^2))
    
    
    #Almacenar valores
    if(b > 1000 &&  (b - 1000) %% 10 == 0){
    #almacenar valores
     THETA[cont,] <-  c(theta, sig2, mu, tau2)
    #Log-verosimilitud
     LL[cont] <- sum(dnorm(x = y, mean = rep(theta, nj), sd = sqrt(sig2), log = T))
     
     cont <- cont+1
    }
  }
  #fin de la cadena
  colnames(THETA) <- c(paste0("theta",1:m), "sig2", "mu", "tau2")
  colnames(LL) <- c("ll")
  THETA <- as.data.frame(THETA)
  LL    <- as.data.frame(LL)
  return(list(THETA = THETA, LL = LL))
}
```

```{r}
# tratamiento de datos
# y  : puntaje de los estudiantes (c)
# Y  : puntaje de los estudiantes (list)
# g  : identificador secuencial de los departamentos (c)
# nj : número de estudiantes por departamento (c)
# yb : promedios por departamento (c)
# s2 : varianzas por departamento (c)
(m <- length(table(datos$COLE_COD_DEPTO_UBICACION)))

y <- datos$PUNT_GLOBAL

Y <- vector(mode = "list", length = m)

#for (j in 1:m) {
#  idx <- datos$COLE_COD_MCPIO_UBICACION == unique(datos$COLE_COD_MCPIO_UBICACION)[j]
#  g[idx] <- j
#  Y[[j]] <- y[idx]
#}
# tabla
estadisticos <- datos %>% 
  group_by(COLE_COD_DEPTO_UBICACION) %>% 
  summarise(codigo = unique(COLE_COD_DEPTO_UBICACION), 
            nombre = unique(COLE_DEPTO_UBICACION), 
            nj = n(), 
            yb = mean(PUNT_GLOBAL), 
            s2 = var(PUNT_GLOBAL))

nj <- estadisticos$nj
yb <- estadisticos$yb
s2 <- estadisticos$s2

# hiperparámetros
mu0  <- 250 
g20  <- 50^2
eta0 <- 1
t20  <- 50^2
nu0  <- 1
s20  <- 50^2

tictoc::tic()
set.seed(2023)
chain2 <- mod2(B = 101000, nj, yb, s2, mu0, g20, eta0, t20, nu0, s20)
tictoc::toc()
```

```{r, graficas cadena 2}
plot(x = 1:10000, y =  unlist(chain2$LL),type = "p", pch = ".", xlab = "Iteración", ylab = "Log-verosimilitud")
plot(chain2$THETA[,1],type = "p", pch = ".", xlab = "Iteración", ylab = expression(theta_1))
plot(chain2$THETA[,2],type = "p", pch = ".", xlab = "Iteración", ylab = expression(theta_2))
plot(chain2$THETA[,m+1],type = "p", pch = ".", xlab = "Iteración", ylab = expression(sigma^2))
plot(chain2$THETA[,m+2],type = "p", pch = ".", xlab = "Iteración", ylab = expression(mu))
plot(chain2$THETA[,m+3],type = "p", pch = ".", xlab = "Iteración", ylab = expression(tau^2))
```

```{r}
save(chain2,file="chain2.Rdata")
```


```{r cadena3}
mod3 <- function(B, nj, yb, s2, mu0, g20, eta0, t20,al0, be0,nu) {
  # tamaños
  n <- sum(nj)
  m <- length(nj)
  
  # valores iniciales
  theta <- yb
  sig2  <- s2  # sigma_j^2
  mu    <- mean(theta)
  tau2  <- var(theta)
  ups2  <- rgamma(n = 1,shape = al0*0.5,rate = be0*0.5)  # sigma^2
  
  #calculos previos
  invg20 <- 1/g20
  mu0_g20 <- mu0/g20
  eta0_m <- eta0+m
  etaxt20 <- eta0*t20 
  a <- (al0 + m*nu)*0.5
  
  cont <- 1
  # almacenamiento
  THETA <- matrix(data = NA, nrow = (B-1000)/10, ncol = 2*m+3)
  LL    <- matrix(data = NA, nrow = (B-1000)/10, ncol = 1)
  
  # cadena
  for (b in 1:B) {
    # actualizar theta
    vtheta <- 1/(1/tau2 + nj/sig2)
    theta  <- rnorm(n = m, mean = vtheta*(mu/tau2 + nj*yb/sig2), sd = sqrt(vtheta))
    
    # actualizar sigma_j^2
    sig2 <- 1/rgamma(n = m, shape = 0.5*(nu + nj), rate = 0.5*(nu*ups2 + (nj-1)*s2 + nj*(yb - theta)^2))
    
    # actualizar mu
    vmu <- 1/(invg20 + m/tau2)
    mu  <- rnorm(n = 1, mean = vmu*(mu0_g20 + m*mean(theta)/tau2), sd = sqrt(vmu))
    
    # actualizar tau2
    tau2 <- 1/rgamma(n = 1, shape = 0.5*(eta0_m), rate = 0.5*(etaxt20 + (m-1)*var(theta) + m*(mean(theta) - mu)^2))
    
    # actualizar sigma^2
    ups2 <- rgamma(n = 1, shape = a, rate = (be0 + nu*sum(1/sig2))*0.5)
    

    # almacenar
    if(b > 1000 && (b - 1000) %% 10 == 0){
    THETA[cont,] <- c(theta, sig2, mu, tau2, ups2)
    # log-verosimilitud
    LL[cont] <- sum(dnorm(x = y, mean = rep(theta, nj), sd = sqrt(rep(sig2, nj)), log = T))
    cont <- cont+1
    }
  }
  
  # fin de la cadena
  # salida
  colnames(THETA) <- c(paste0("theta", 1:m), paste0("sig2", 1:m), "mu", "tau2", "ups2")
  colnames(LL) <- c("ll")
  THETA <- as.data.frame(THETA)
  LL    <- as.data.frame(LL)
  return(list(THETA = THETA, LL = LL))
}
```


```{r cadena3}
(m <- length(table(datos$COLE_COD_DEPTO_UBICACION)))

y <- datos$PUNT_GLOBAL

Y <- vector(mode = "list", length = m)

estadisticos <- datos %>% 
  group_by(COLE_COD_DEPTO_UBICACION) %>% 
  summarise(codigo = unique(COLE_COD_DEPTO_UBICACION), 
            nombre = unique(COLE_DEPTO_UBICACION), 
            nj = n(), 
            yb = mean(PUNT_GLOBAL), 
            s2 = var(PUNT_GLOBAL))

nj <- estadisticos$nj
yb <- estadisticos$yb
s2 <- estadisticos$s2

# hiperparámetros
  mu0  <- 250 
  g20  <- 50^2
  eta0 <- 1  
  t20  <- 50^2
  nu <- 1
  al0  <- 1
  be0  <- 1/50^2 

tictoc::tic()
set.seed(2023)
chain3 <- mod3(B = 101000, nj, yb, s2, mu0, g20, eta0, t20,al0,be0,nu)
tictoc::toc()

```

```{r, graficas cadena 3}
plot(x = 1:10000, y =  unlist(chain3$LL),type = "p", pch = ".", xlab = "Iteración", ylab = "Log-verosimilitud")
plot(chain3$THETA[,1],type = "p", pch = ".", xlab = "Iteración", ylab = expression(theta_1))
plot(chain3$THETA[,2],type = "p", pch = ".", xlab = "Iteración", ylab = expression(theta_2))
plot(chain3$THETA[,m+1],type = "p", pch = ".", xlab = "Iteración", ylab = expression(sigma^2))
plot(chain3$THETA[,m+2],type = "p", pch = ".", xlab = "Iteración", ylab = expression(sigma_2))
plot(chain3$THETA$tau2,type = "p", pch = ".", xlab = "Iteración", ylab = expression(tau))
plot(chain3$THETA$mu,type = "p", pch = ".", xlab = "Iteración", ylab = expression(mu))
plot(chain3$THETA$ups2,type = "p", pch = ".", xlab = "Iteración", ylab = expression(ups))
```
```{r}
save(chain3,file="chain3.Rdata")
```

