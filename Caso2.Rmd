---
title: "Caso 2"
author: "Sebastián Lozano, Jherson Guzman"
date: "7/10/2023"
output: pdf_document
---

```{r setup, include=FALSE}
setwd("C:/Bayesiana/Caso2")
```


```{r, include=FALSE,include=FALSE}
Sys.setlocale(category = "LC_COLLATE", locale = "Spanish_Colombia.utf8")
Sys.setlocale(category = "LC_CTYPE", locale = "Spanish_Colombia.utf8")
Sys.setlocale(category = "LC_MONETARY", locale = "Spanish_Colombia.utf8")
Sys.setlocale(category = "LC_NUMERIC", locale = "C")
Sys.setlocale(category = "LC_TIME", locale = "Spanish_Colombia.utf8")
```


```{r cargar datos, y librería,include=FALSE}
library(readr)
library(readxl)
library(dplyr)
library(ggplot2)

#setwd("C:/Users/57300/OneDrive/Documentos/GitHub/BayesianStatsCase2")
Saber11 <- read_delim("C:/Bayesiana/Caso2/SB11_20222.TXT", 
  delim = ";", escape_double = FALSE, locale = locale(), 
  trim_ws = TRUE)

```

```{r Tratamiento de datos, include=FALSE}
#Nacionalidad colombiana
#Residencia en Colombia
#Proceso de investigación en el Icfes en estado de “Publicar”.
#Ubicación del colegio no es San Andrés.
#Sin datos faltantes en la ubicación del colegio por municipio, la ubicación del colegio por departamento y el puntaje global

datos <- Saber11 %>%
  filter(ESTU_NACIONALIDAD == "COLOMBIA"&
           ESTU_PAIS_RESIDE == "COLOMBIA" &
            COLE_COD_DEPTO_UBICACION != 88 &
           ESTU_ESTADOINVESTIGACION=="PUBLICAR" 
           ) %>%
  as.data.frame()

nrow(datos)

#ya hay 525061

# cambiamos COLE_COD_DEPTO_UBICACION a char
datos$COLE_COD_DEPTO_UBICACION<-as.character(datos$COLE_COD_DEPTO_UBICACION)
datos$COLE_COD_DEPTO_UBICACION<-ifelse(datos$COLE_COD_DEPTO_UBICACION=="5","05",datos$COLE_COD_DEPTO_UBICACION)
datos$COLE_COD_DEPTO_UBICACION<-ifelse(datos$COLE_COD_DEPTO_UBICACION=="8","08",datos$COLE_COD_DEPTO_UBICACION)

# cambiamos COLE_COD_MCPIO_UBICACION a char
datos$COLE_COD_MCPIO_UBICACION<-as.character(datos$COLE_COD_MCPIO_UBICACION)
datos$COLE_COD_MCPIO_UBICACION<-ifelse(datos$COLE_COD_DEPTO_UBICACION=="05",paste("0",datos$COLE_COD_MCPIO_UBICACION,sep=""),datos$COLE_COD_MCPIO_UBICACION)
datos$COLE_COD_MCPIO_UBICACION<-ifelse(datos$COLE_COD_DEPTO_UBICACION=="08",paste("0",datos$COLE_COD_MCPIO_UBICACION,sep=""),datos$COLE_COD_MCPIO_UBICACION)


# Revisamos que no hayan datos faltantes
sum(is.na(datos$COLE_COD_MCPIO_UBICACION))
sum(is.na(datos$COLE_COD_DEPTO_UBICACION))
sum(is.na(datos$PUNT_GLOBAL))

##Guardamos los datos, para su posterior manipulación.
#save(datos, file = "saber11modificado.rdata")

```

## Punto 1
```{r preparacion de la base de datos, include=FALSE}
combinados <- cbind(datos$COLE_DEPTO_UBICACION,datos$COLE_COD_DEPTO_UBICACION)
cod <- as.data.frame(unique(combinados))
cod <- setNames(cod, c("dep", "cod_dep"))
```

```{r, include=FALSE}
pobreza_monetaria <- read_excel("C:/Bayesiana/Caso2/pobreza monetaria.xls",sheet = "Pobreza Monetaria (%)", range = "A16:P40")

pobreza_monetaria <- pobreza_monetaria[,c(1,16)]
pobreza_monetaria <- setNames(pobreza_monetaria,c("dep","IP2018"))

codigos_departamentos <- c("05", "08", "11", "13", "15", "17", "18", "19", "20", "27", "23", "25", "41", "44", "47", "50", "52", "54", "63", "66", "68", "70", "73", "76")

pobreza_monetaria$cod_dep <- codigos_departamentos

punt_muestrales <- datos %>%
  group_by(COLE_COD_DEPTO_UBICACION) %>%
  summarise(puntmedio = mean(PUNT_GLOBAL)) %>%
  as.data.frame()

Mapa <- punt_muestrales %>%
  full_join(pobreza_monetaria,by = c("COLE_COD_DEPTO_UBICACION"="cod_dep"))%>%
  select(COLE_COD_DEPTO_UBICACION,dep,IP2018,puntmedio) %>%
  as.data.frame()

Mapa <- setNames(Mapa,c("cod_dep","dep","IP2018","puntmedio"))
```

```{r gráficas, include=FALSE}
library(sf)

deptoshp <- st_read("MGN_DPTO_POLITICO.shp",quiet=TRUE) 

mapdeptos <- deptoshp %>%
  left_join(Mapa,by=c("DPTO_CCDGO"="cod_dep")) 

mundoshp <- st_read("admin00.shp",quiet=TRUE)
mundocol <- mundoshp %>% 
            filter(CNTRY_NAME %in% c("Peru","Brazil","Venezuela","Ecuador","Panama"))
str(mundocol)
```

```{r}
library(ggplot2)
box <- st_bbox(mapdeptos)

plot1 <- ggplot() +
  geom_sf(data = mundocol) +
  geom_sf(data = mapdeptos, aes(fill = puntmedio), col = "darkgray", linetype = "solid") +
  coord_sf(xlim = c(box$xmin, box$xmax), ylim = c(box$ymin, box$ymax), expand = FALSE) +
  geom_sf_text(data = mapdeptos, aes(label = ifelse(puntmedio < quantile(puntmedio, probs = 0.10, na.rm = TRUE), DPTO_CNMBR, "")), col = "black",
               fontface = "bold", size = 2, fun.geometry = function(x) sf::st_centroid(x)) +
  labs(x = "Longitud", y = "Latitud", title = "Puntaje medio en las \npruebas Saber Pro \ndepartamento en 2022-II", fill = "Puntaje \nmedio") +
  scale_fill_gradient(low = "white", high = "#00FFFF", n.breaks = 5)

plot2 <- ggplot() +
  geom_sf(data = mundocol) +
  geom_sf(data = mapdeptos, aes(fill = IP2018), col = "darkgray", linetype = "solid") +
  coord_sf(xlim = c(box$xmin, box$xmax), ylim = c(box$ymin, box$ymax), expand = FALSE) +
  geom_sf_text(data = mapdeptos, aes(label = ifelse(IP2018 > quantile(IP2018, probs = 0.90, na.rm = TRUE), DPTO_CNMBR, "")), col = "black",
               fontface = "bold", size = 2, fun.geometry = function(x) sf::st_centroid(x)) +
  labs(x = "Longitud", y = "Latitud", title = "Índice de pobreza \npor departamento en\n2018", fill = "Índice de \n pobreza" ) +
  scale_fill_gradient(low = "white", high = "#FFD700", n.breaks = 5)

```

```{r}
library(gridExtra)
grid.arrange(plot1, plot2, ncol = 2)
```

## Punto 2

```{r}
library(readr)
library(stringr)
estadisticas_edu <- read_delim("estadísticas_educación.csv",delim = ",")

estadisticas_edu <- estadisticas_edu %>%
  filter(AÑO == 2022) %>%
  select(AÑO,CÓDIGO_MUNICIPIO,MUNICIPIO,CÓDIGO_DEPARTAMENTO,DEPARTAMENTO,COBERTURA_NETA_SECUNDARIA) %>%
  as.data.frame()

punt_muestrales_mpios <- datos %>%
  group_by(COLE_COD_MCPIO_UBICACION) %>%
  summarise(puntmedio = mean(PUNT_GLOBAL)) %>%
  as.data.frame()

punt_muestrales_mpios$COLE_COD_MCPIO_UBICACION <- sub("^00", "0", punt_muestrales_mpios$COLE_COD_MCPIO_UBICACION)

Mapa_mpios <- punt_muestrales_mpios %>%
  full_join(estadisticas_edu,by = c("COLE_COD_MCPIO_UBICACION"="CÓDIGO_MUNICIPIO"))%>%
  as.data.frame()


```
```{r}
mpioshp <- st_read("MGN_MPIO_POLITICO.shp",quiet=TRUE) 
mpioshp$MPIO_COD <- paste(mpioshp$DPTO_CCDGO,mpioshp$MPIO_CCDGO,sep = "")

mapmpios <- mpioshp %>%
  left_join(Mapa_mpios,by=c("MPIO_COD"="COLE_COD_MCPIO_UBICACION")) 

mundoshp <- st_read("admin00.shp",quiet=TRUE)
mundocol <- mundoshp %>% 
            filter(CNTRY_NAME %in% c("Peru","Brazil","Venezuela","Ecuador","Panama"))
```

```{r}
box2 <- st_bbox(mapmpios)

plot3 <- ggplot() +
  geom_sf(data = mundocol) +
  geom_sf(data = mapmpios, aes(fill = puntmedio), col = "gray", linetype = "solid") +
  coord_sf(xlim = c(box2$xmin, box2$xmax), ylim = c(box2$ymin, box2$ymax), expand = FALSE) +
  labs(x = "Longitud", y = "Latitud", title = "Puntaje medio en las \npruebas Saber Pro \npor municipio en 2022-II", fill = "Puntaje \nmedio") +
  scale_fill_gradient(low = "white", high = "#00FFFF", n.breaks = 5)

plot4 <- ggplot() +
  geom_sf(data = mundocol) +
  geom_sf(data = mapmpios, aes(fill = COBERTURA_NETA_SECUNDARIA), col = "gray", linetype = "solid") +
  coord_sf(xlim = c(box2$xmin, box2$xmax), ylim = c(box2$ymin, box2$ymax), expand = FALSE) +
  labs(x = "Longitud", y = "Latitud", title = "Cobertura neta \nsecundaria por municipio \nen 2022", fill = "Cob. \nneta \nsec." ) +
  scale_fill_gradient(low = "white", high = "#00CD00", n.breaks = 5)
```


```{r}
grid.arrange(plot3, plot4, ncol = 2)
```


```{r Implementación Modelos}
mod1 <- function(B,y,mu0,gamma0,nu0,s20){
  #tamaños
  n <- length(y)
  ybar <- mean(y)
  ysum <- sum(y)
  s2 <- var(y)
  
  #valores inicales
  sig2 <- 1/rgamma(n = 1,shape = nu0/2,rate = (nu0*s20)/2)
  
  #calculos previos 
  invgamma0 <- 1/gamma0
  mu0_gamma0 <- mu0/gamma0
  nun_2 <- (n + nu0)/2
  nun <- n+nu0
  nu0xs20 <- nu0*s20
  
  cont <- 1
  #almacenamiento
  THETA <- matrix(data = NA, nrow = (B-1000)/10, ncol = 2)
  LL <- matrix(data = NA, nrow = (B-1000)/10, ncol = 1)
  
  #cadena
  for (b in 1:B) {
    #actualizar theta
    vtheta <- 1/(n/sig2+invgamma0)
    theta <- rnorm(n = 1, mean = (ysum/sig2 + mu0_gamma0)*vtheta, sd = sqrt(vtheta))
    
    #actualizar sigma^2
    
    sig2 <- 1/rgamma(n = 1, shape =  nun_2, rate = 0.5*(nu0xs20+(n-1)*s2+n*(ybar-theta)^2))
    
    
    if(b > 1000 &&  (b - 1000) %% 10 == 0){
    #almacenar valores
     THETA[cont,] <-  c(theta,sig2)
    #Log-verosimilitud
     LL[cont] <- sum(dnorm(x = y, mean = theta, sd = sqrt(sig2),log = TRUE))
     
     cont <- cont+1
    }
  }
  

  #fin de la cadena
  

  colnames(THETA) <- c("theta","sig2")
  colnames(LL) <- c("ll")
  
  THETA <- THETA[!rowSums(is.na(THETA)) == ncol(THETA), ]
  LL <- LL[!rowSums(is.na(LL)) == ncol(LL), ]
  
  #salida
  
  THETA <- as.data.frame(THETA)
  LL <- as.data.frame(LL)
  return(list(THETA = THETA,LL = LL))
}
```


```{r calculo modelo 1}
#Hiperparametros
y <- datos$PUNT_GLOBAL
mu0 <- 250
gamma0 <- 50^2
nu0 <- 1 
s20 <- 50^2


tictoc::tic()
set.seed(2023)
chain1 <- mod1(B = 101000, y = y,mu0 = mu0,gamma0 = gamma0, nu0 = nu0, s20 = s20)
tictoc::toc()
```
```{r, graficas cadena 1}
plot(x = 1:10000, y =  unlist(chain1$LL),type = "p", pch = ".", xlab = "Iteración", ylab = "Log-verosimilitud")
plot(chain1$THETA[,1],type = "p", pch = ".", xlab = "Iteración", ylab = expression(theta))
plot(chain1$THETA[,2],type = "p", pch = ".", xlab = "Iteración", ylab = expression(sigma^2))
```

```{r}
mod2 <- function(B,nj,yb,s2,mu0, g20, eta0, t20, nu0, s20){
  #tamaño 
  n <- sum(nj)
  m <- length(nj)
  
  #valores inciales
  theta <- yb
  sig2  <- mean(s2)
  mu    <- mean(theta)
  tau2  <- var(theta)
  
  #calculos previos
  invg20 <- 1/g20
  mu0_g20 <- mu0/g20
  eta0_m <- eta0+m
  #almacenamiento
  THETA <- matrix(data = NA, nrow = (B-1000)/10, ncol = m+3)
  LL    <- matrix(data = NA, nrow = (B-1000)/10, ncol = 1)
  
  cont <- 1
  #cadena
  for (b in 1:B) {
    #actualizar theta
    vtheta <- 1/(1/tau2 + nj/sig2)
    theta  <- rnorm(n = m, mean = vtheta*(mu/tau2 + nj*yb/sig2), sd = sqrt(vtheta))
    
    #actualizar sigma^2
    sig2 <- 1/rgamma(n = 1, shape = 0.5*(nu0 + n), rate = 0.5*(nu0*s20 + sum((nj-1)*s2 + nj*(yb - theta)^2)))
    
    # actualizar mu
    vmu <- 1/(invg20 + m/tau2)
    mu  <- rnorm(n = 1, mean = vmu*(mu0_g20 + m*mean(theta)/tau2), sd = sqrt(vmu)) 
    
    # actualizar tau^2
    tau2 <- 1/rgamma(n = 1, shape = 0.5*(eta0_m), rate = 0.5*(eta0*t20 + (m-1)*var(theta) + m*(mean(theta) - mu)^2))
    
    
    #Almacenar valores
    if(b > 1000 &&  (b - 1000) %% 10 == 0){
    #almacenar valores
     THETA[cont,] <-  c(theta, sig2, mu, tau2)
    #Log-verosimilitud
     LL[cont] <- sum(dnorm(x = y, mean = rep(theta, nj), sd = sqrt(sig2), log = T))
     
     cont <- cont+1
    }
  }
  #fin de la cadena
  colnames(THETA) <- c(paste0("theta",1:m), "sig2", "mu", "tau2")
  colnames(LL) <- c("ll")
  THETA <- as.data.frame(THETA)
  LL    <- as.data.frame(LL)
  return(list(THETA = THETA, LL = LL))
}
```

```{r}
# tratamiento de datos
# y  : puntaje de los estudiantes (c)
# Y  : puntaje de los estudiantes (list)
# g  : identificador secuencial de los departamentos (c)
# nj : número de estudiantes por departamento (c)
# yb : promedios por departamento (c)
# s2 : varianzas por departamento (c)
(m <- length(table(datos$COLE_COD_DEPTO_UBICACION)))

y <- datos$PUNT_GLOBAL

Y <- vector(mode = "list", length = m)

#for (j in 1:m) {
#  idx <- datos$COLE_COD_MCPIO_UBICACION == unique(datos$COLE_COD_MCPIO_UBICACION)[j]
#  g[idx] <- j
#  Y[[j]] <- y[idx]
#}
# tabla
estadisticos <- datos %>% 
  group_by(COLE_COD_DEPTO_UBICACION) %>% 
  summarise(codigo = unique(COLE_COD_DEPTO_UBICACION), 
            nombre = unique(COLE_DEPTO_UBICACION), 
            nj = n(), 
            yb = mean(PUNT_GLOBAL), 
            s2 = var(PUNT_GLOBAL))

nj <- estadisticos$nj
yb <- estadisticos$yb
s2 <- estadisticos$s2

# hiperparámetros
mu0  <- 250 
g20  <- 50^2
eta0 <- 1
t20  <- 50^2
nu0  <- 1
s20  <- 50^2

tictoc::tic()
set.seed(2023)
chain2 <- mod2(B = 101000, nj, yb, s2, mu0, g20, eta0, t20, nu0, s20)
tictoc::toc()
```

```{r, graficas cadena 2}
plot(x = 1:10000, y =  unlist(chain2$LL),type = "p", pch = ".", xlab = "Iteración", ylab = "Log-verosimilitud")
plot(chain2$THETA[,1],type = "p", pch = ".", xlab = "Iteración", ylab = expression(theta_1))
plot(chain2$THETA[,2],type = "p", pch = ".", xlab = "Iteración", ylab = expression(theta_2))
plot(chain2$THETA[,m+1],type = "p", pch = ".", xlab = "Iteración", ylab = expression(sigma^2))
plot(chain2$THETA[,m+2],type = "p", pch = ".", xlab = "Iteración", ylab = expression(mu))
plot(chain2$THETA[,m+3],type = "p", pch = ".", xlab = "Iteración", ylab = expression(tau^2))
```

```{r}
save(chain2,file="chain2.Rdata")
```


```{r cadena3}
mod3 <- function(B, nj, yb, s2, mu0, g20, eta0, t20,al0, be0,nu) {
  # tamaños
  n <- sum(nj)
  m <- length(nj)
  
  # valores iniciales
  theta <- yb
  sig2  <- s2  # sigma_j^2
  mu    <- mean(theta)
  tau2  <- var(theta)
  ups2  <- rgamma(n = 1,shape = al0*0.5,rate = be0*0.5)  # sigma^2
  
  #calculos previos
  invg20 <- 1/g20
  mu0_g20 <- mu0/g20
  eta0_m <- eta0+m
  etaxt20 <- eta0*t20 
  a <- (al0 + m*nu)*0.5
  
  cont <- 1
  # almacenamiento
  THETA <- matrix(data = NA, nrow = (B-1000)/10, ncol = 2*m+3)
  LL    <- matrix(data = NA, nrow = (B-1000)/10, ncol = 1)
  
  # cadena
  for (b in 1:B) {
    # actualizar theta
    vtheta <- 1/(1/tau2 + nj/sig2)
    theta  <- rnorm(n = m, mean = vtheta*(mu/tau2 + nj*yb/sig2), sd = sqrt(vtheta))
    
    # actualizar sigma_j^2
    sig2 <- 1/rgamma(n = m, shape = 0.5*(nu + nj), rate = 0.5*(nu*ups2 + (nj-1)*s2 + nj*(yb - theta)^2))
    
    # actualizar mu
    vmu <- 1/(invg20 + m/tau2)
    mu  <- rnorm(n = 1, mean = vmu*(mu0_g20 + m*mean(theta)/tau2), sd = sqrt(vmu))
    
    # actualizar tau2
    tau2 <- 1/rgamma(n = 1, shape = 0.5*(eta0_m), rate = 0.5*(etaxt20 + (m-1)*var(theta) + m*(mean(theta) - mu)^2))
    
    # actualizar sigma^2
    ups2 <- rgamma(n = 1, shape = a, rate = (be0 + nu*sum(1/sig2))*0.5)
    

    # almacenar
    if(b > 1000 && (b - 1000) %% 10 == 0){
    THETA[cont,] <- c(theta, sig2, mu, tau2, ups2)
    # log-verosimilitud
    LL[cont] <- sum(dnorm(x = y, mean = rep(theta, nj), sd = sqrt(rep(sig2, nj)), log = T))
    cont <- cont+1
    }
  }
  
  # fin de la cadena
  # salida
  colnames(THETA) <- c(paste0("theta", 1:m), paste0("sig2", 1:m), "mu", "tau2", "ups2")
  colnames(LL) <- c("ll")
  THETA <- as.data.frame(THETA)
  LL    <- as.data.frame(LL)
  return(list(THETA = THETA, LL = LL))
}
```


```{r cadena3}
(m <- length(table(datos$COLE_COD_DEPTO_UBICACION)))

y <- datos$PUNT_GLOBAL

Y <- vector(mode = "list", length = m)

estadisticos <- datos %>% 
  group_by(COLE_COD_DEPTO_UBICACION) %>% 
  summarise(codigo = unique(COLE_COD_DEPTO_UBICACION), 
            nombre = unique(COLE_DEPTO_UBICACION), 
            nj = n(), 
            yb = mean(PUNT_GLOBAL), 
            s2 = var(PUNT_GLOBAL))

nj <- estadisticos$nj
yb <- estadisticos$yb
s2 <- estadisticos$s2

# hiperparámetros
  mu0  <- 250 
  g20  <- 50^2
  eta0 <- 1  
  t20  <- 50^2
  nu <- 1
  al0  <- 1
  be0  <- 1/50^2 

tictoc::tic()
set.seed(2023)
chain3 <- mod3(B = 101000, nj, yb, s2, mu0, g20, eta0, t20,al0,be0,nu)
tictoc::toc()

```

```{r, graficas cadena 3}
plot(x = 1:10000, y =  unlist(chain3$LL),type = "p", pch = ".", xlab = "Iteración", ylab = "Log-verosimilitud")
plot(chain3$THETA[,1],type = "p", pch = ".", xlab = "Iteración", ylab = expression(theta_1))
plot(chain3$THETA[,2],type = "p", pch = ".", xlab = "Iteración", ylab = expression(theta_2))
plot(chain3$THETA[,m+1],type = "p", pch = ".", xlab = "Iteración", ylab = expression(sigma^2))
plot(chain3$THETA[,m+2],type = "p", pch = ".", xlab = "Iteración", ylab = expression(sigma_2))
plot(chain3$THETA$tau2,type = "p", pch = ".", xlab = "Iteración", ylab = expression(tau))
plot(chain3$THETA$mu,type = "p", pch = ".", xlab = "Iteración", ylab = expression(mu))
plot(chain3$THETA$ups2,type = "p", pch = ".", xlab = "Iteración", ylab = expression(ups))
```


```{r}
save(chain3,file="chain3.Rdata")
```



```{r}
estadisticas_mpios <- datos %>%
  mutate(COLE_COD_MCPIO_UBICACION = ifelse(substr(COLE_COD_MCPIO_UBICACION, 1, 1) == "0", substr(COLE_COD_MCPIO_UBICACION, 2, nchar(COLE_COD_MCPIO_UBICACION)), COLE_COD_MCPIO_UBICACION)) %>%
  group_by(COLE_COD_MCPIO_UBICACION) %>%
  summarise(codigo = unique(COLE_COD_MCPIO_UBICACION),
            nombre = unique(COLE_MCPIO_UBICACION),
            njk = n(),
            ybjk = mean(PUNT_GLOBAL),
            s2jk = var(PUNT_GLOBAL)) %>%
  arrange(codigo)

estadisticas_mpios <- estadisticas_mpios %>%
  mutate(COD_DEPARTAMENTO = substr(COLE_COD_MCPIO_UBICACION, 1, 2))

conteo_deptos <- estadisticas_mpios %>%
  group_by(COD_DEPARTAMENTO) %>%
  summarise(codigo = unique(COD_DEPARTAMENTO),
            nk = n())

nk <- conteo_deptos$nk

estadisticas_deptos <- datos %>%
  group_by(COLE_COD_DEPTO_UBICACION) %>%
  summarise(codigo = unique(COLE_COD_DEPTO_UBICACION),
            nombre = unique(COLE_DEPTO_UBICACION),
            nk = n(),
            ybk = mean(PUNT_GLOBAL),
            s2k = var(PUNT_GLOBAL))%>%
  arrange(COLE_COD_DEPTO_UBICACION)


njk <- estadisticas_mpios$njk
ybjk <- estadisticas_mpios$ybjk
s2jk <- estadisticas_mpios$s2jk


ybd <- estadisticas_deptos$ybk
s2d <- estadisticas_deptos$s2k

#B,njk,ybk,s2jk,nk,ybd,s2d,xi0,k20,mu0,g20,eta0,tau20,nu0,s20

#hiperparametros
B <- 101000
xi0 <- 1
k20 <- 50^2
mu0 <- 250
g20 <- 50^2
eta0 <- 1
tau20 <- 50^2
nu0 <- 1
s20 <- 50^2
y<-datos$PUNT_GLOBAL
```

```{r}
mod4 <- function(B,njk,ybk,s2jk,nk,ybd,s2d,xi0,k20,mu0,g20,eta0,tau20,nu0,s20){
  
#tamaños 
  N <- sum(njk)
  lennjk <- length(njk)
  sumnk <- sum(nk)
  m <- length(nk)

#valores inciales
  theta <- rnorm(n = m, mean = ybd, sd = sqrt(s2d))
  k2 <- 1/rgamma(n = 1, shape = xi0*0.5,rate = (xi0*k20)*0.5)
  mu <- rnorm(n = 1, mean = mu0,sd = sqrt(s20))
  tau2 <- 1/rgamma(n = 1, shape = eta0*0.5,rate = (eta0*tau20)*0.5)
  sig2 <- 1/rgamma(n=1, shape = nu0*0.5,rate = (nu0*s20)*0.5)
  
#calculos previos
  xi0xk20  <- xi0*k20
  N_xi0 <- N+xi0
  invg20 <- 1/g20
  mu0_g20 <- mu0/g20
  m_eta0_2 <- 0.5*(m+eta0)
  eta0xtau20 <- eta0*tau20
  sumnk_nu0 <- sumnk+nu0 
  nu0xs20 <- nu0*s20
  
  start <- 1
  end <- 0
  cont <- 1
  
  #Almacenamiento
  ZETA <- matrix(data = NA, nrow = (B-1000)/10, ncol = lennjk)
  THETA <- matrix(data = NA,nrow = (B-1000)/10, ncol = m)
  OTROS <- matrix(data = NA, nrow = (B-1000)/10,ncol =  4)
  LL    <- matrix(data = NA, nrow = (B-1000)/10, ncol = 1)
  
  for (b in 1:B) {
    #actualizar zeta
    vzeta <- 1/(njk/k2 + 1/sig2)
    zeta <- rnorm(n = lennjk ,mean = vzeta*((njk*ybjk)/k2+rep(theta,nk)/sig2),sd = sqrt(vzeta))
    
    zetabar <- tapply(zeta, rep(1:m, times = nk), FUN = mean)
    vzeta <- tapply(zeta, rep(1:m, times = nk), FUN = var)
    vzeta[3] <- 0
    
    #actualizar kappa^2
    k2 <- 1/rgamma(n = 1, shape = 0.5*(N_xi0),rate = 0.5*(xi0xk20 + sum((njk-1)*s2jk+njk*(ybjk-zeta)^2)))
    
    #actualizar theta
    vtheta <- 1/((nk/sig2+1/tau2))
    theta <- rnorm(n = m,mean = vtheta*((nk*zetabar)/sig2+mu/tau2),sd=sqrt(vtheta))
    
    thetabar <- mean(theta)
    stheta <- var(theta)
    
    #actualizar mu 
    vmu <- 1/(m/tau2 + invg20)
    mu <- rnorm(n=1, mean = vmu*((m*thetabar)/tau2+mu0_g20), sd = sqrt(vmu))
    
    #actualizar tau^2
    tau2 <- 1/rgamma(n = 1,shape = m_eta0_2,rate = 0.5*(eta0xtau20+(m-1)*stheta+m*(thetabar-mu)^2))
    
    #actualizar sig2
    sig2 <- 1/rgamma(n = 1,shape = sumnk_nu0,rate = 0.5*(nu0xs20+sum((nk-1)*vzeta + nk*(zetabar-theta)^2)))
    
    if((b - 1000) %% 10 == 0 && b > 1000){
      ZETA[cont,] <- zeta
      THETA[cont,] <- theta
      OTROS[cont,] <- c(k2,mu,tau2,sig2)
      LL[cont] <- sum(dnorm(x = y, mean = rep(zeta, njk), sd = sqrt(k2), log = T))
      cont <- cont+1
    }
  }
  #colnames(THETA) <- c(paste0("theta", 1:m), paste0("sig2", 1:m), "mu", "tau2", "ups2")
  colnames(ZETA) <- c(paste0("zeta",1:lennjk))
  colnames(THETA) <- c(paste0("theta",1:m))
  colnames(OTROS) <- c("k2","mu","tau2","sig2")
  colnames(LL) <- c("ll")
  
  ZETA <- as.data.frame(ZETA)
  THETA <- as.data.frame(THETA)
  OTROS <- as.data.frame(OTROS)
  LL <- as.data.frame(LL)
  
  
  return(list(ZETA = ZETA,THETA = THETA,OTROS = OTROS,LL = LL))
}
```


```{r}
tictoc::tic()
set.seed(2023)
chain4 <- mod4(B,njk,ybk,s2jk,nk,ybd,s2d,xi0,k20,mu0,g20,eta0,tau20,nu0,s20)
tictoc::toc()
```


```{r}
plot(x = 1:10000, y =  unlist(chain4$LL),type = "p", pch = ".", xlab = "Iteración", ylab = "Log-verosimilitud")

plot(chain4$ZETA[,12],type = "p", pch = ".", xlab = "Iteración", ylab = expression(zeta))
plot(chain4$THETA[,4],type = "p", pch = ".", xlab = "Iteración", ylab = expression(theta))
plot(chain4$OTROS[,1],type = "p", pch = ".", xlab = "Iteración", ylab = expression(kappa))
plot(chain4$OTROS[,2],type = "p", pch = ".", xlab = "Iteración", ylab = expression(mu))
plot(chain4$OTROS[,3],type = "p", pch = ".", xlab = "Iteración", ylab = expression(tau))
plot(chain4$OTROS[,4],type = "p", pch = ".", xlab = "Iteración", ylab = expression(sigma))
```



```{r}
save(chain4,file="chain4.Rdata")
```

```{r}
neffotros <- coda::effectiveSize(chain4$OTROS)
nefftheta <- coda::effectiveSize(chain4$THETA)
neffzeta <- coda::effectiveSize(chain4$ZETA)
```

```{r}
round(neffotros,digits = 3)
round(apply(X = chain4$OTROS, MARGIN = 2, FUN = sd)/sqrt(neffotros), 3)
```


```{r}
round(summary(apply(X = chain4$THETA, MARGIN = 2, FUN = sd)/sqrt(nefftheta)), 3)
```


```{r}
round(summary(apply(X = chain4$ZETA, MARGIN = 2, FUN = sd)/sqrt(neffzeta)), 3)
```

```{r}
mod5 <- function(B,njk,ybjk,s2jk,nk,ybd,s2d,xi0,k20,mu0,g20,tau20,eta0,nu,al0,be0){
  
  #tamaños
  N <- sum(njk)
  lennjk <- length(njk)
  sumnk <- sum(nk)
  m <- length(nk)
  
  #valores iniciales
  theta <- ybd
  k2 <- 1/rgamma(n = 1, shape = xi0*0.5,rate = (xi0*k20)*0.5)
  mu <- rnorm(n = 1, mean = mu0,sd = sqrt(s20))
  tau2 <- 1/rgamma(n = 1, shape = eta0*0.5,rate = (eta0*tau20)*0.5)
  sig2 <- s2d
  ups <- rgamma(n = 1, shape = al0*0.5 , rate = be0*0.5)
  
  #calculos previos
  xi0xk20  <- xi0*k20
  N_xi0 <- N+xi0
  invg20 <- 1/g20
  mu0_g20 <- mu0/g20
  m_eta0_2 <- 0.5*(m+eta0)
  eta0xtau20 <- eta0*tau20
  nk_nu <- nk + nu
  nu_al0_2 <- 0.5*(nu+al0)
  
  cont <- 1
  
  #almacenamiento
  ZETA <- matrix(data = NA, nrow = (B-1000)/10, ncol = lennjk)
  THETA <- matrix(data = NA,nrow = (B-1000)/10, ncol = m)
  SIG2 <- matrix(data = NA,nrow = (B-1000)/10, ncol = m)
  OTROS <- matrix(data = NA, nrow = (B-1000)/10,ncol =  4)
  LL    <- matrix(data = NA, nrow = (B-1000)/10, ncol = 1)
  
  for (b in 1:B) {
    #actualizar zeta
    vzeta <- 1/(njk/k2 + 1/rep(sig2,nk))
    zeta <- rnorm(n = lennjk, mean = vzeta*((njk*ybjk)/k2+rep(theta,nk)/rep(sig2,nk)))
    
    zeta_bar <- tapply(zeta, rep(1:m, times = nk), FUN = mean)
    var_zeta <- tapply(zeta, rep(1:m, times = nk), FUN = var)
    var_zeta[3] <- 0
    
    #actualizar k2
    k2 <- 1/rgamma(n = 1, shape = 0.5*(N_xi0),rate = 0.5*(xi0xk20 + sum((njk-1)*s2jk+njk*(ybjk-zeta)^2)))
    
    #actualizar theta 
    vtheta <- 1/(nk/sig2+1/tau2)
    theta <- rnorm(n = m,mean = vtheta*((nk*zeta_bar)/sig2+mu/tau2),sd=sqrt(vtheta))
    
    theta_bar <- mean(theta)
    var_theta <- var(theta)
    
    #actualizar mu
    vmu <- 1/(m/tau2 + invg20)
    mu <- rnorm(n=1, mean = vmu*((m*theta_bar)/tau2+mu0_g20), sd = sqrt(vmu))
    
    #actualizar tau2
    tau2 <- 1/rgamma(n = 1,shape = m_eta0_2,rate = 0.5*(eta0xtau20+(m-1)*var_theta+m*(theta_bar-mu)^2))
    
    #actualizar sig2
    sig2 <- 1/rgamma(n = m, shape = 0.5*(nk_nu),rate = 0.5*(nu*ups+(nk-1)*var_zeta + nk*(zeta_bar-theta)^2))
    
    #actualizar ups
    ups <- rgamma(n = 1, shape = nu_al0_2,rate = 0.5*(be0+nu*sum(1/sig2)))
    
    if((b - 1000) %% 10 == 0 && b > 1000){
      ZETA[cont,] <- zeta
      THETA[cont,] <- theta
      SIG2[cont,] <- sig2
      OTROS[cont,] <- c(k2,mu,tau2,ups)
      LL[cont] <- sum(dnorm(x = y, mean = rep(zeta, njk), sd = sqrt(k2), log = T))
      cont <- cont+1
    }
  }
  
  colnames(ZETA) <- c(paste0("zeta",1:lennjk))
  colnames(THETA) <- c(paste0("theta",1:m))
  colnames(SIG2) <- c(paste0("sig2",1:m))
  colnames(OTROS) <- c("k2","mu","tau2","ups")
  colnames(LL) <- c("ll")
  
  ZETA <- as.data.frame(ZETA)
  THETA <- as.data.frame(THETA)
  SIG2 <- as.data.frame(SIG2)
  OTROS <- as.data.frame(OTROS)
  LL <- as.data.frame(LL)
  
  
  return(list(ZETA = ZETA,THETA = THETA,SIG2 = SIG2,OTROS = OTROS,LL = LL))
}
```

```{r}
estadisticas_mpios <- datos %>%
  mutate(COLE_COD_MCPIO_UBICACION = ifelse(substr(COLE_COD_MCPIO_UBICACION, 1, 1) == "0", substr(COLE_COD_MCPIO_UBICACION, 2, nchar(COLE_COD_MCPIO_UBICACION)), COLE_COD_MCPIO_UBICACION)) %>%
  group_by(COLE_COD_MCPIO_UBICACION) %>%
  summarise(codigo = unique(COLE_COD_MCPIO_UBICACION),
            nombre = unique(COLE_MCPIO_UBICACION),
            njk = n(),
            ybjk = mean(PUNT_GLOBAL),
            s2jk = var(PUNT_GLOBAL)) %>%
  arrange(codigo)

estadisticas_mpios <- estadisticas_mpios %>%
  mutate(COD_DEPARTAMENTO = substr(COLE_COD_MCPIO_UBICACION, 1, 2))

conteo_deptos <- estadisticas_mpios %>%
  group_by(COD_DEPARTAMENTO) %>%
  summarise(codigo = unique(COD_DEPARTAMENTO),
            nk = n())

nk <- conteo_deptos$nk

estadisticas_deptos <- datos %>%
  group_by(COLE_COD_DEPTO_UBICACION) %>%
  summarise(codigo = unique(COLE_COD_DEPTO_UBICACION),
            nombre = unique(COLE_DEPTO_UBICACION),
            nk = n(),
            ybk = mean(PUNT_GLOBAL),
            s2k = var(PUNT_GLOBAL))%>%
  arrange(COLE_COD_DEPTO_UBICACION)


njk <- estadisticas_mpios$njk
ybjk <- estadisticas_mpios$ybjk
s2jk <- estadisticas_mpios$s2jk


ybd <- estadisticas_deptos$ybk
s2d <- estadisticas_deptos$s2k


#B,njk,ybjk,s2jk,nk,ybd,s2d,xi0,k20,mu0,g20,tau20,eta0,nu,al0,be0

#hiperparametros
B <- 101000
xi0 <- 1
k20 <- 50^2
mu0 <- 250
g20 <- 50^2
eta0 <- 1
tau20 <- 50^2
nu <- 1
al0 <- 1
be0 <- 1/50^2
y<-datos$PUNT_GLOBAL
```

```{r}
tictoc::tic()
set.seed(2023)
chain5 <- mod5(B,njk,ybjk,s2jk,nk,ybd,s2d,xi0,k20,mu0,g20,tau20,eta0,nu,al0,be0)
tictoc::toc()
```


```{r}
plot(x = 1:10000, y =  unlist(chain5$LL),type = "p", pch = ".", xlab = "Iteración", ylab = "Log-verosimilitud")

plot(chain5$ZETA[,1032],type = "p", pch = ".", xlab = "Iteración", ylab = expression(zeta))
plot(chain5$ZETA[,187],type = "p", pch = ".", xlab = "Iteración", ylab = expression(zeta))
plot(chain5$ZETA[,286],type = "p", pch = ".", xlab = "Iteración", ylab = expression(zeta))
plot(chain5$ZETA[,122],type = "p", pch = ".", xlab = "Iteración", ylab = expression(zeta))
plot(chain5$ZETA[,356],type = "p", pch = ".", xlab = "Iteración", ylab = expression(zeta))

plot(chain5$THETA[,14],type = "p", pch = ".", xlab = "Iteración", ylab = expression(theta))
plot(chain5$THETA[,15],type = "p", pch = ".", xlab = "Iteración", ylab = expression(theta))
plot(chain5$THETA[,3],type = "p", pch = ".", xlab = "Iteración", ylab = expression(theta))


plot(chain5$SIG2[,3],type = "p",pch = ".",xlab = "Iteración",ylab = expression(sigma))
plot(chain5$SIG2[,17],type = "p",pch = ".",xlab = "Iteración",ylab = expression(sigma))
plot(chain5$SIG2[,11],type = "p",pch = ".",xlab = "Iteración",ylab = expression(sigma))

plot(chain5$OTROS[,1],type = "p", pch = ".", xlab = "Iteración", ylab = expression(kappa))
plot(chain5$OTROS[,2],type = "p", pch = ".", xlab = "Iteración", ylab = expression(mu))
plot(chain5$OTROS[,3],type = "p", pch = ".", xlab = "Iteración", ylab = expression(tau))
plot(chain5$OTROS[,4],type = "p", pch = ".", xlab = "Iteración", ylab = expression(ups))
```

```{r}
neffotros_5 <- coda::effectiveSize(chain5$OTROS)
nefftheta_5 <- coda::effectiveSize(chain5$THETA)
neffsig2_5 <- coda::effectiveSize(chain5$SIG2)
neffzeta_5 <- coda::effectiveSize(chain5$ZETA)
```

```{r}
round(neffotros_5,digits = 3)
round(apply(X = chain5$OTROS, MARGIN = 2, FUN = sd)/sqrt(neffotros_5), 3)
```


```{r}
round(summary(apply(X = chain5$THETA, MARGIN = 2, FUN = sd)/sqrt(nefftheta_5)), 3)
```
```{r}
round(summary(apply(X = chain5$SIG2, MARGIN = 2, FUN = sd)/sqrt(neffsig2_5)), 3)
```


```{r}
round(summary(apply(X = chain5$ZETA, MARGIN = 2, FUN = sd)/sqrt(neffzeta_5)), 3)
```
```{r}
round(summary(apply(X = chain5$SIG2, MARGIN = 2, FUN = sd)/sqrt(neffsig2_5)), 3)
```




```{r}
save(chain5,file = "chain5.Rdata")
```


```{r}
(neff_theta_1 <- coda::effectiveSize(chain1$THETA[,1]))
(neff_sig2_1 <- coda::effectiveSize(chain1$THETA[,2]))


sd(chain1$THETA[,1]/sqrt(neff_theta_1))
sd(chain1$THETA[,2]/sqrt(neff_theta_1))

#round(apply(X = chain1$THETA[,1], MARGIN = 2, FUN = sd)/sqrt(neff_theta_1), 3)
#round(apply(X = chain1$THETA[,2], MARGIN = 2, FUN = sd)/sqrt(neff_sig2_1), 3)
```


```{r Punto 4}
par(mfrow = c(2, 2))

# Gráfico 1 (negro)
plot(x = 1:10000, y = unlist(chain2$LL), type = "p", pch = ".", xlab = "Iteración", ylab = "Log-verosimilitud", col = "black", ylim = c(-2873285, -2836923))
title("M2")

# Gráfico 2 (rojo)
plot(x = 1:10000, y = unlist(chain3$LL), type = "p", pch = ".", xlab = "Iteración", ylab = "Log-verosimilitud", col = "red",ylim = c(-2873285, -2836923))
title("M3")

# Gráfico 3 (azul)
plot(x = 1:10000, y = unlist(chain4$LL), type = "p", pch = ".", xlab = "Iteración", ylab = "Log-verosimilitud", col = "blue",ylim = c(-2873285, -2836923))
title("M4")

# Gráfico 4 (verde)
plot(x = 1:10000, y = unlist(chain5$LL), type = "p", pch = ".", xlab = "Iteración", ylab = "Log-verosimilitud", col = "green",ylim = c(-2873285, -2836923))
title("M5")




```

```{r  Punto 6}

vecmu <- cbind(chain1$THETA[,1],chain2$THETA$mu,chain3$THETA$mu,chain4$OTROS$mu,chain5$OTROS$mu)

medias <- apply(vecmu, MARGIN = 2, mean)
medias <- round(medias, digits = 3)

ICs <- apply(vecmu, MARGIN = 2, function(x) quantile(x, c(0.025, 0.975)))
ICs <- round(ICs, digits = 3)

punto_6 <- rbind(medias,ICs)

`colnames<-`(punto_6,c("M1","M2","M3","M4","M5"))
print(punto_6)
```

